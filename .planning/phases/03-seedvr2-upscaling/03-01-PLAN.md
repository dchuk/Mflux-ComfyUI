---
phase: 03-seedvr2-upscaling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Mflux_Comfy/Mflux_SeedVR2.py
  - __init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SeedVR2 loader node appears in ComfyUI node browser under mflux category"
    - "User can connect ComfyUI IMAGE output to upscale node input"
    - "User can select scale factor (1x, 2x, 4x) via multiplier or longest side mode"
    - "User can adjust softness parameter (0.0-1.0)"
    - "Upscaled image outputs as ComfyUI IMAGE type"
    - "Output dimensions string shows input->output size calculation"
  artifacts:
    - path: "Mflux_Comfy/Mflux_SeedVR2.py"
      provides: "MfluxSeedVR2Loader and MfluxSeedVR2Upscaler node classes"
      min_lines: 150
    - path: "__init__.py"
      provides: "Platform-gated SeedVR2 node registration"
      contains: "_SEEDVR2_NODES_AVAILABLE"
  key_links:
    - from: "Mflux_Comfy/Mflux_SeedVR2.py"
      to: "mflux.models.seedvr2.SeedVR2"
      via: "conditional import in load_model()"
      pattern: "from mflux.models.seedvr2 import SeedVR2"
    - from: "__init__.py"
      to: "Mflux_Comfy/Mflux_SeedVR2.py"
      via: "conditional import if _is_apple_silicon()"
      pattern: "from .Mflux_Comfy.Mflux_SeedVR2 import"
    - from: "MfluxSeedVR2Upscaler"
      to: "utils.tensor_utils.pil_to_comfy_tensor"
      via: "output conversion"
      pattern: "pil_to_comfy_tensor"
---

<objective>
Create SeedVR2 diffusion upscaling nodes following the Z-Image loader/sampler pattern.

Purpose: Enable users to upscale any ComfyUI IMAGE using SeedVR2's diffusion-based super-resolution model with configurable scale factors and softness control.

Output: Two new nodes (MfluxSeedVR2Loader, MfluxSeedVR2Upscaler) registered under "mflux" category with platform gating for Apple Silicon only.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-seedvr2-upscaling/03-CONTEXT.md
@.planning/phases/03-seedvr2-upscaling/03-RESEARCH.md
@.planning/phases/02-zimage-turbo/02-01-SUMMARY.md
@Mflux_Comfy/Mflux_ZImage.py
@__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SeedVR2 nodes module</name>
  <files>Mflux_Comfy/Mflux_SeedVR2.py</files>
  <action>
Create new file `Mflux_Comfy/Mflux_SeedVR2.py` following the exact pattern from `Mflux_ZImage.py`:

**Module structure:**
1. Module docstring describing nodes
2. Standard imports (os, time, uuid, numpy, torch, PIL.Image, folder_paths)
3. Internal imports from utils (tensor_utils, memory_utils)
4. Environment variable guards (MFLUX_COMFY_DISABLE_MLX_IMPORT, MFLUX_COMFY_DISABLE_MFLUX_IMPORT)
5. Conditional mflux imports for SeedVR2 and ModelConfig
6. Model cache dict (_seedvr2_cache)

**MfluxSeedVR2Loader class:**
- INPUT_TYPES:
  - `quantize`: ["4", "8", "None"], default "4", tooltip explaining memory/quality tradeoffs
  - `clear_cache_after_use`: BOOLEAN, default True, with label_on="Clear after each", label_off="Keep cached"
- RETURN_TYPES: ("SEEDVR2_MODEL",)
- RETURN_NAMES: ("model",)
- CATEGORY: "mflux" (not "MFlux/SeedVR2" - per CONTEXT.md: "all mflux nodes together")
- FUNCTION: "load_model"
- load_model method:
  - Check SeedVR2/ModelConfig imports succeeded
  - Parse quantize ("None" -> None, else int())
  - Cache key: ("seedvr2", q_val)
  - If not cached: clear cache, print loading message, instantiate SeedVR2 with ModelConfig.seedvr2_3b()
  - Return dict with "model" and "clear_cache" keys wrapped in tuple

**MfluxSeedVR2Upscaler class:**
- INPUT_TYPES:
  - `model`: ("SEEDVR2_MODEL",) with tooltip
  - `image`: ("IMAGE",) with tooltip "ComfyUI IMAGE to upscale (from any source)"
  - `scale_mode`: ["Multiplier", "Longest Side"], default "Multiplier"
  - `multiplier`: ["1x", "2x", "4x"], default "4x"
  - `longest_side`: INT, default 2048, min 64, max 8192
  - `softness`: FLOAT, default 0.0, min 0.0, max 1.0, step 0.1, tooltip "0.0 = sharpest, 1.0 = maximum softness"
  - `seed`: INT, default 42, min 0, max 0xffffffffffffffff
- RETURN_TYPES: ("IMAGE", "STRING",)
- RETURN_NAMES: ("image", "dimensions",)
- CATEGORY: "mflux"
- FUNCTION: "upscale"
- upscale method:
  - Extract model and clear_cache flag from model dict
  - Get input dimensions from tensor shape [B, H, W, C]
  - Save tensor to temp file using _save_tensor_to_temp helper
  - Determine resolution: ScaleFactor for multiplier mode, int for longest_side mode
  - Calculate output dimensions using _calculate_dimensions helper
  - Format dimensions string: "{input_w}x{input_h} -> {output_w}x{output_h}"
  - Call seedvr2_model.generate_image(seed, image_path, resolution, softness)
  - Extract PIL image from result (handle result.image or raw result)
  - Convert to ComfyUI tensor via pil_to_comfy_tensor
  - In finally block: clean up temp file, clear MLX memory if clear_cache is True
  - Return (output_tensor, dims_string)

**Helper functions:**
- `_save_tensor_to_temp(tensor, prefix="seedvr2_input")`: Copy from Mflux_ZImage.py pattern
- `_calculate_dimensions(input_w, input_h, resolution)`: Per 03-RESEARCH.md code example

**Critical implementation notes from RESEARCH.md:**
- SeedVR2 takes image_path (str/Path), NOT tensor - use temp file
- SeedVR2 uses ScaleFactor for multiplier, int for target resolution
- Resolution is based on shortest edge (per SeedVR2Util.preprocess_image)
- Output dimensions rounded to multiple of 2
- No prompt parameter - SeedVR2 uses pre-computed embeddings
- No steps parameter - hardcoded to 1 internally
- Clean up temp file in finally block to prevent disk bloat
  </action>
  <verify>
    - File exists at Mflux_Comfy/Mflux_SeedVR2.py
    - File contains MfluxSeedVR2Loader class with INPUT_TYPES, RETURN_TYPES, CATEGORY, FUNCTION
    - File contains MfluxSeedVR2Upscaler class with INPUT_TYPES, RETURN_TYPES, CATEGORY, FUNCTION
    - CATEGORY is "mflux" for both classes
    - File has conditional mflux imports with guards
    - File imports from utils.tensor_utils and utils.memory_utils
  </verify>
  <done>
    - MfluxSeedVR2Loader accepts quantize (4/8/None) and clear_cache_after_use boolean
    - MfluxSeedVR2Upscaler accepts IMAGE input, scale_mode, multiplier, longest_side, softness, seed
    - Upscaler returns (IMAGE, STRING) tuple with upscaled image and dimensions string
    - Temp files cleaned up after each upscale
    - MLX memory cleared based on user's cache preference
  </done>
</task>

<task type="auto">
  <name>Task 2: Update node registration with platform gating</name>
  <files>__init__.py</files>
  <action>
Modify `__init__.py` to add SeedVR2 nodes following the exact pattern used for Z-Image nodes:

**Inside the try block (after Z-Image imports, around line 40):**
```python
    # Conditionally import SeedVR2 nodes only on Apple Silicon
    if _is_apple_silicon():
        try:
            from .Mflux_Comfy.Mflux_SeedVR2 import (
                MfluxSeedVR2Loader,
                MfluxSeedVR2Upscaler,
            )
            _SEEDVR2_NODES_AVAILABLE = True
        except ImportError:
            _SEEDVR2_NODES_AVAILABLE = False
    else:
        _SEEDVR2_NODES_AVAILABLE = False
```

**Inside the except block fallback (after Z-Image fallback imports):**
Add parallel structure for SeedVR2 imports using direct imports (not relative).

**After NODE_DISPLAY_NAME_MAPPINGS (around line 130):**
```python
# Conditionally add SeedVR2 nodes (Apple Silicon only)
if _SEEDVR2_NODES_AVAILABLE:
    NODE_CLASS_MAPPINGS["MfluxSeedVR2Loader"] = MfluxSeedVR2Loader
    NODE_CLASS_MAPPINGS["MfluxSeedVR2Upscaler"] = MfluxSeedVR2Upscaler
    NODE_DISPLAY_NAME_MAPPINGS["MfluxSeedVR2Loader"] = "MFlux SeedVR2 Loader"
    NODE_DISPLAY_NAME_MAPPINGS["MfluxSeedVR2Upscaler"] = "MFlux SeedVR2 Upscaler"
```

**Important:** Follow the same dual-path pattern (try/except blocks) used for Z-Image to handle both package and direct import scenarios.
  </action>
  <verify>
    - __init__.py contains `_SEEDVR2_NODES_AVAILABLE` variable
    - __init__.py contains conditional import for MfluxSeedVR2Loader and MfluxSeedVR2Upscaler
    - NODE_CLASS_MAPPINGS updated conditionally based on _SEEDVR2_NODES_AVAILABLE
    - NODE_DISPLAY_NAME_MAPPINGS has entries for SeedVR2 nodes
    - Python syntax valid: `python -c "import ast; ast.parse(open('__init__.py').read())"`
  </verify>
  <done>
    - SeedVR2 nodes only register on Apple Silicon (platform gating active)
    - Non-Apple Silicon systems see no errors and no SeedVR2 nodes
    - Display names are "MFlux SeedVR2 Loader" and "MFlux SeedVR2 Upscaler"
    - Node registration follows same pattern as Z-Image nodes
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Syntax check:** `python -c "import ast; ast.parse(open('Mflux_Comfy/Mflux_SeedVR2.py').read()); ast.parse(open('__init__.py').read())"`
2. **Import check (Apple Silicon):** `python -c "from Mflux_Comfy.Mflux_SeedVR2 import MfluxSeedVR2Loader, MfluxSeedVR2Upscaler; print('Import OK')"`
3. **Node inspection:**
   - MfluxSeedVR2Loader.INPUT_TYPES() returns dict with "quantize" and optional "clear_cache_after_use"
   - MfluxSeedVR2Upscaler.INPUT_TYPES() returns dict with model, image, scale_mode, multiplier, longest_side, softness, seed
   - Both have CATEGORY == "mflux"
</verification>

<success_criteria>
- MfluxSeedVR2Loader node exists with quantize and cache toggle inputs
- MfluxSeedVR2Upscaler node exists accepting IMAGE input with scale/softness controls
- Both nodes in "mflux" category
- Platform gating prevents registration on non-Apple Silicon
- Dimensions string output shows calculated size transformation
- Temp files cleaned up after upscale
- MLX memory management respects user's cache preference
</success_criteria>

<output>
After completion, create `.planning/phases/03-seedvr2-upscaling/03-01-SUMMARY.md`
</output>
