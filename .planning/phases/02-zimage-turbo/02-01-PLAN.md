---
phase: 02-zimage-turbo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Mflux_Comfy/Mflux_ZImage.py
  - __init__.py
autonomous: true

must_haves:
  truths:
    - "Z-Image Turbo loader node appears in ComfyUI node browser under mflux category"
    - "User can load Z-Image Turbo model with 4-bit, 8-bit, or no quantization"
    - "User can enter text prompt and generate an image that appears in ComfyUI preview"
    - "User can set seed, steps, width, height and see parameters affect output"
    - "User can connect input image for img2img workflow with denoise control"
    - "Nodes do not appear on non-Apple Silicon systems (silent non-registration)"
  artifacts:
    - path: "Mflux_Comfy/Mflux_ZImage.py"
      provides: "Z-Image loader, sampler, and img2img nodes"
      min_lines: 200
      contains: "class MfluxZImageLoader"
    - path: "__init__.py"
      provides: "Node registration with platform gating"
      contains: "MfluxZImageLoader"
  key_links:
    - from: "Mflux_Comfy/Mflux_ZImage.py"
      to: "Mflux_Comfy/utils/tensor_utils.py"
      via: "import pil_to_comfy_tensor"
      pattern: "from .utils.tensor_utils import"
    - from: "Mflux_Comfy/Mflux_ZImage.py"
      to: "Mflux_Comfy/utils/memory_utils.py"
      via: "import clear_mlx_memory"
      pattern: "from .utils.memory_utils import"
    - from: "__init__.py"
      to: "Mflux_Comfy/Mflux_ZImage.py"
      via: "conditional import with platform check"
      pattern: "_is_apple_silicon"
---

<objective>
Create dedicated Z-Image Turbo nodes following user's architectural decisions from CONTEXT.md: separate loader, txt2img sampler, and img2img nodes.

Purpose: Users can load the Z-Image Turbo model once and connect it to either txt2img or img2img sampler nodes for generation, following ComfyUI's standard loader/sampler pattern.

Output:
- New file `Mflux_Comfy/Mflux_ZImage.py` with three node classes
- Updated `__init__.py` with platform-gated registration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-zimage-turbo/02-CONTEXT.md
@.planning/phases/02-zimage-turbo/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Reference implementations
@Mflux_Comfy/Mflux_Air.py
@Mflux_Comfy/Mflux_Core.py
@Mflux_Comfy/Mflux_Pro.py
@Mflux_Comfy/utils/tensor_utils.py
@Mflux_Comfy/utils/memory_utils.py
@__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Z-Image nodes module with loader and samplers</name>
  <files>Mflux_Comfy/Mflux_ZImage.py</files>
  <action>
Create new file `Mflux_Comfy/Mflux_ZImage.py` with three node classes:

**MfluxZImageLoader:**
- INPUT_TYPES:
  - `model`: Dropdown scanning local models folder (reuse `is_model_directory` pattern from Mflux_Air.py) + HuggingFace cached + alias "z-image-turbo"
  - `quantize`: ("4", "8", "None") with default "4", tooltip explaining each option
- RETURN_TYPES: ("ZIMAGE_MODEL",)
- CATEGORY: "mflux"
- FUNCTION: "load_model"
- Implementation:
  - Import ZImageTurbo, ModelConfig from mflux (with guards)
  - Convert quantize string to int or None
  - Load model using ZImageTurbo(quantize=q, model_path=path, model_config=ModelConfig.z_image_turbo())
  - Use model_cache pattern from Mflux_Core.py to avoid reloading (cache key = model + quantize)
  - Return model instance

**MfluxZImageSampler:**
- INPUT_TYPES:
  - `model`: ("ZIMAGE_MODEL",) with tooltip
  - `prompt`: STRING multiline with default "A cinematic shot..."
  - `seed`: INT default 42, min 0, max 0xffffffffffffffff
  - `steps`: INT default 8, min 1, max 50
  - `width`: INT default 512, min 64, max 2048, step 64
  - `height`: INT default 512, min 64, max 2048, step 64
- RETURN_TYPES: ("IMAGE",)
- CATEGORY: "mflux"
- FUNCTION: "generate"
- Implementation:
  - Call model.generate_image(seed, prompt, num_inference_steps, height, width)
  - NO guidance parameter (Z-Image Turbo hardcodes 0.0)
  - Extract PIL image from result (result.image if hasattr else result)
  - Convert using pil_to_comfy_tensor()
  - Call clear_mlx_memory() in finally block
  - Return (image_tensor,)

**MfluxZImageImg2Img:**
- INPUT_TYPES:
  - `model`: ("ZIMAGE_MODEL",)
  - `init_image`: ("IMAGE",) with tooltip "Starting image for transformation"
  - `prompt`: STRING multiline
  - `denoise`: FLOAT default 0.5, min 0.0, max 1.0, step 0.01, tooltip explaining 0=keep image, 1=ignore
  - `seed`: INT default 42
  - `steps`: INT default 8, min 1, max 50
- RETURN_TYPES: ("IMAGE",)
- CATEGORY: "mflux"
- FUNCTION: "generate"
- Implementation:
  - Save init_image tensor to temp file using _save_tensor_to_temp pattern from Mflux_Pro.py
  - Get height/width from tensor shape (tensor.shape[1], tensor.shape[2])
  - Map denoise to image_strength: image_strength = 1.0 - denoise
  - Call model.generate_image(seed, prompt, num_inference_steps, height, width, image_path=temp_path, image_strength=strength)
  - Convert result to tensor, cleanup memory
  - Return (image_tensor,)

**Imports at top:**
- Standard: os, time, uuid, numpy, torch, PIL.Image
- From parent: folder_paths
- From utils: pil_to_comfy_tensor, comfy_tensor_to_pil, clear_mlx_memory
- Conditional mflux imports with guards (ZImageTurbo, ModelConfig)

**Helper functions:**
- `_is_model_directory(path)` - copy pattern from Mflux_Air.py
- `_scan_zimage_models()` - scan local + cached + aliases, return list
- `_save_tensor_to_temp(tensor, prefix)` - copy pattern from Mflux_Pro.py

Model cache: Use module-level dict `_model_cache = {}` with key (model_path, quantize).
  </action>
  <verify>
```bash
python3 -c "
import sys
sys.path.insert(0, '.')
# Set env to skip actual MLX/mflux loading for syntax check
import os
os.environ['MFLUX_COMFY_DISABLE_MLX_IMPORT'] = '1'
os.environ['MFLUX_COMFY_DISABLE_MFLUX_IMPORT'] = '1'
from Mflux_Comfy.Mflux_ZImage import MfluxZImageLoader, MfluxZImageSampler, MfluxZImageImg2Img
print('Loader INPUT_TYPES:', list(MfluxZImageLoader.INPUT_TYPES()['required'].keys()))
print('Sampler INPUT_TYPES:', list(MfluxZImageSampler.INPUT_TYPES()['required'].keys()))
print('Img2Img INPUT_TYPES:', list(MfluxZImageImg2Img.INPUT_TYPES()['required'].keys()))
print('All 3 node classes import successfully')
"
```
  </verify>
  <done>
- MfluxZImageLoader exists with model/quantize inputs, returns ZIMAGE_MODEL
- MfluxZImageSampler exists with model/prompt/seed/steps/width/height inputs, returns IMAGE
- MfluxZImageImg2Img exists with model/init_image/prompt/denoise/seed/steps inputs, returns IMAGE
- All three classes have CATEGORY = "mflux"
- Uses Phase 1 utilities for tensor conversion and memory management
  </done>
</task>

<task type="auto">
  <name>Task 2: Update node registration with platform gating</name>
  <files>__init__.py</files>
  <action>
Update `__init__.py` to:

1. Add platform check function at top (before any imports):
```python
import platform
import sys

def _is_apple_silicon():
    return sys.platform == "darwin" and platform.machine() == "arm64"
```

2. Conditionally import new Z-Image nodes ONLY if Apple Silicon:
```python
if _is_apple_silicon():
    try:
        from .Mflux_Comfy.Mflux_ZImage import (
            MfluxZImageLoader,
            MfluxZImageSampler,
            MfluxZImageImg2Img,
        )
        _ZIMAGE_NODES_AVAILABLE = True
    except ImportError:
        _ZIMAGE_NODES_AVAILABLE = False
else:
    _ZIMAGE_NODES_AVAILABLE = False
```

3. Add to NODE_CLASS_MAPPINGS conditionally:
```python
if _ZIMAGE_NODES_AVAILABLE:
    NODE_CLASS_MAPPINGS["MfluxZImageLoader"] = MfluxZImageLoader
    NODE_CLASS_MAPPINGS["MfluxZImageSampler"] = MfluxZImageSampler
    NODE_CLASS_MAPPINGS["MfluxZImageImg2Img"] = MfluxZImageImg2Img
```

4. Add display names conditionally:
```python
if _ZIMAGE_NODES_AVAILABLE:
    NODE_DISPLAY_NAME_MAPPINGS["MfluxZImageLoader"] = "MFlux Z-Image Loader"
    NODE_DISPLAY_NAME_MAPPINGS["MfluxZImageSampler"] = "MFlux Z-Image Sampler"
    NODE_DISPLAY_NAME_MAPPINGS["MfluxZImageImg2Img"] = "MFlux Z-Image Img2Img"
```

IMPORTANT: Keep existing MfluxZImageNode registration for backward compatibility. The new nodes are ADDITIONS, not replacements.

NOTE: The platform check ensures nodes simply don't appear on non-Apple systems, per CONTEXT.md "silent non-registration" requirement.
  </action>
  <verify>
```bash
python3 -c "
import sys
sys.path.insert(0, '.')
import platform

# Check platform detection
from __init__ import _is_apple_silicon
is_as = _is_apple_silicon()
print(f'Is Apple Silicon: {is_as}')
print(f'Platform: {sys.platform}, Machine: {platform.machine()}')

# Check node registration
from __init__ import NODE_CLASS_MAPPINGS, NODE_DISPLAY_NAME_MAPPINGS
if is_as:
    assert 'MfluxZImageLoader' in NODE_CLASS_MAPPINGS, 'MfluxZImageLoader not registered'
    assert 'MfluxZImageSampler' in NODE_CLASS_MAPPINGS, 'MfluxZImageSampler not registered'
    assert 'MfluxZImageImg2Img' in NODE_CLASS_MAPPINGS, 'MfluxZImageImg2Img not registered'
    print('All 3 new nodes registered')
else:
    print('Non-Apple Silicon: nodes should not be registered (this is expected)')

# Verify backward compatibility - old node still exists
assert 'MfluxZImageNode' in NODE_CLASS_MAPPINGS, 'Legacy MfluxZImageNode missing'
print('Legacy MfluxZImageNode preserved for backward compatibility')
"
```
  </verify>
  <done>
- `_is_apple_silicon()` function exists and correctly detects platform
- On Apple Silicon: all 3 new nodes appear in NODE_CLASS_MAPPINGS
- On non-Apple Silicon: new nodes do not appear (silent non-registration)
- Legacy MfluxZImageNode remains registered for backward compatibility
- Display names mapped correctly
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Syntax/Import Check:**
```bash
python3 -c "import sys; sys.path.insert(0, '.'); from __init__ import NODE_CLASS_MAPPINGS; print(f'Total nodes: {len(NODE_CLASS_MAPPINGS)}')"
```

2. **Node Structure Check:**
```bash
python3 -c "
import sys, os
sys.path.insert(0, '.')
os.environ['MFLUX_COMFY_DISABLE_MLX_IMPORT'] = '1'
os.environ['MFLUX_COMFY_DISABLE_MFLUX_IMPORT'] = '1'
from Mflux_Comfy.Mflux_ZImage import MfluxZImageLoader, MfluxZImageSampler, MfluxZImageImg2Img

# Verify categories
assert MfluxZImageLoader.CATEGORY == 'mflux'
assert MfluxZImageSampler.CATEGORY == 'mflux'
assert MfluxZImageImg2Img.CATEGORY == 'mflux'

# Verify return types
assert MfluxZImageLoader.RETURN_TYPES == ('ZIMAGE_MODEL',)
assert MfluxZImageSampler.RETURN_TYPES == ('IMAGE',)
assert MfluxZImageImg2Img.RETURN_TYPES == ('IMAGE',)

# Verify key inputs
loader_inputs = MfluxZImageLoader.INPUT_TYPES()['required']
assert 'model' in loader_inputs and 'quantize' in loader_inputs

sampler_inputs = MfluxZImageSampler.INPUT_TYPES()['required']
assert 'model' in sampler_inputs and 'prompt' in sampler_inputs

img2img_inputs = MfluxZImageImg2Img.INPUT_TYPES()['required']
assert 'init_image' in img2img_inputs and 'denoise' in img2img_inputs

print('All node structures verified')
"
```

3. **Requirement Coverage:**
- INFRA-05: Nodes appear under "mflux" category
- ZIMG-01: Loader with quantization selection (4-bit, 8-bit, none)
- ZIMG-02: Sampler generates image from text prompt
- ZIMG-03: Seed, steps, width, height parameters available
- ZIMG-04: Img2Img node with denoise (strength) control
- ZIMG-05: Returns standard ComfyUI IMAGE type
</verification>

<success_criteria>
- [ ] Mflux_Comfy/Mflux_ZImage.py exists with 200+ lines
- [ ] MfluxZImageLoader, MfluxZImageSampler, MfluxZImageImg2Img classes defined
- [ ] All three nodes have CATEGORY = "mflux"
- [ ] Loader returns ZIMAGE_MODEL type
- [ ] Samplers return IMAGE type
- [ ] Uses Phase 1 utilities (tensor_utils, memory_utils)
- [ ] __init__.py has platform check function
- [ ] New nodes registered only on Apple Silicon
- [ ] Legacy MfluxZImageNode preserved
- [ ] All verification commands pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-zimage-turbo/02-01-SUMMARY.md` using the summary template.
</output>
